import fs from "node:fs";
import fsp from "node:fs/promises";
import path from "node:path";

/**
 * Minimal CSV parser for controlled inputs (no quotes/commas inside fields).
 * Keep your CSV simple: no embedded commas; use hyphens for slugs.
 */
function parseCSV(text) {
  const lines = text.split(/\r?\n/).filter(Boolean);
  const header = lines.shift().split(",").map(s => s.trim());
  return lines.map(line => {
    const cols = line.split(",").map(s => s.trim());
    const row = {};
    header.forEach((h, i) => { row[h] = cols[i] ?? ""; });
    return row;
  });
}

function num(v) {
  if (v === undefined || v === null || v === "") return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

function cleanStr(v) {
  if (v === undefined || v === null) return null;
  const s = String(v).trim();
  return s.length ? s : null;
}

function toCity(row) {
  // Map CSV row to City object (see lib/types.ts)
  return {
    slug: String(row.slug),
    name: String(row.name),
    state: String(row.state),

    state_fips: cleanStr(row.state_fips),
    place_geoid: cleanStr(row.place_geoid),
    county_fips: cleanStr(row.county_fips),
    cbsa_code: cleanStr(row.cbsa_code),
    geo_level: cleanStr(row.geo_level),

    pop: num(row.pop),

    rpp: Number(row.rpp ?? 0),
    rentIndex: Number(row.rentIndex ?? 0),
    incomeMedian: Number(row.incomeMedian ?? 0),
    diversityIndex: Number(row.diversityIndex ?? 0),
    internetMbps: Number(row.internetMbps ?? 0),
    parksPer10k: Number(row.parksPer10k ?? 0),
    cafesPer10k: Number(row.cafesPer10k ?? 0),
    barsPer10k: Number(row.barsPer10k ?? 0),
    climate: String(row.climate ?? ""),

    commuteMedian: num(row.commuteMedian),
    transitShare: num(row.transitShare),
  };
}

function cityToTs(c) {
  // Stable key order for readability
  const o = {
    slug: c.slug, name: c.name, state: c.state,
    state_fips: c.state_fips ?? null,
    place_geoid: c.place_geoid ?? null,
    county_fips: c.county_fips ?? null,
    cbsa_code: c.cbsa_code ?? null,
    geo_level: c.geo_level ?? null,
    pop: c.pop ?? null,
    rpp: c.rpp,
    rentIndex: c.rentIndex,
    incomeMedian: c.incomeMedian,
    diversityIndex: c.diversityIndex,
    internetMbps: c.internetMbps,
    parksPer10k: c.parksPer10k,
    cafesPer10k: c.cafesPer10k,
    barsPer10k: c.barsPer10k,
    climate: c.climate,
    commuteMedian: c.commuteMedian ?? null,
    transitShare: c.transitShare ?? null,
  };
  // Manual pretty-print (avoid extra deps)
  const json = JSON.stringify(o, null, 2)
    .replace(/"(\w+)":/g, "$1:")     // strip quotes on keys (valid TS object literal)
    .replace(/: null/g, ": null");    // be explicit about nulls
  return json;
}

async function main() {
  const root = process.cwd();
  const inputPath = path.join(root, "data", "inputs", "cities_base.csv");
  const outPath = path.join(root, "lib", "data", "cities.ts");
  const typesImport = `import type { City } from "@/lib/types";\n`;

  if (!fs.existsSync(inputPath)) {
    console.error(`Missing ${inputPath}. Please create it (template below).`);
    process.exit(1);
  }

  const text = await fsp.readFile(inputPath, "utf8");
  const rows = parseCSV(text);
  if (!rows.length) {
    console.error("No rows in cities_base.csv");
    process.exit(1);
  }

  const cities = rows.map(toCity);

  const header =
`// AUTO-GENERATED by scripts/build-cities.mjs â€“ do not hand-edit.
// Source: data/inputs/cities_base.csv
${typesImport}
export const CITIES: City[] = [
`;

  const body = cities.map(c => "  " + cityToTs(c)).join(",\n");
  const footer = "\n];\n";

  const fileText = header + body + footer;

  await fsp.writeFile(outPath, fileText, "utf8");
  console.log(`Wrote ${outPath} with ${cities.length} cities.`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
